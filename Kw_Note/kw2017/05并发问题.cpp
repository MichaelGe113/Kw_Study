/* 死锁 */
1.CONC.DL
死锁
  多线程程序中的死锁指的是两个或多个线程相互阻止，各自等待对方完成的情况。
这通常由无序的锁争用引起，其中，每个线程均保留有另一个线程所需的资源，
因此只有在获得资源后，两者才能解除阻止。

  通常，死锁由无序保留的循环锁链引起。例如，线程 1 所执行代码的锁保留模式要求锁A先于
锁B保留，同时，线程 2 所执行代码（可能相同）的锁保留模式要求锁 B 先于锁 A 保留。
如果这两个线程在执行过程中发生冲突，线程 1 将可能在线程 2 已保留锁 B 后请求该锁。
线程 2 可能请求锁 A，但会受到阻止，因为线程 1 已经保留该锁。

  CONC.DL 检查器可查找死锁实例。

漏洞与风险
  此类型的循环锁引用可能导致程序死机、UI 无效、设备无响应以及类似问题。
现场调试这些问题很可能花费开发人员数周时间，同时也会让客户沮丧。

缓解与预防
为了帮助避免锁争用：
  请尝试让代码的锁定部分尽可能小和简单以便于理解。
  勿锁定可能导致数据竞争等并发问题的代码部分。
  务必避免循环等待的状况。
  如果使用多个锁（通常在升级保护模式下），务必确保在每种情况下已执行完全相同的升级操作。



/* 漏解锁 */
2.CONC.NO_UNLOCK
漏洞与风险
  漏释放锁定可能导致死锁。如果一个锁定保留且未释放，则无法
继续进行任何调用来获取该锁定，除非释放该锁定。
缓解与预防
为了帮助避免锁争用：
  请尝试让代码的锁定部分尽可能小和简单以便于理解。
  勿锁定可能导致数据竞争等并发问题的代码部分。
  务必避免循环等待的状况。
  如果使用多个锁（通常在升级保护模式下），务必确保在每种情况下已执行完全相同的升级操作。
  1  #include <pthread.h>
  2
  3  extern int z();
  4
  5  void foo(pthread_mutex_t *mutex) {
  6    pthread_mutex_lock(mutex);
  7    switch (z()) {
  8      case 0:
  9        return;
  10     case 1:
  11       break;
  12   }
  13   pthread_mutex_unlock(mutex);
  14 }
  Klocwork 报告如果事例 0 生效，互斥将在第 6 行锁定并且不会在第 9 行解锁。
修正：
  在return前一行加：
  pthread_mutex_unlock(mutex);


调用关键部分的阻止函数
3.CONC.SLEEP
漏洞与风险
  执行阻止函数前，锁定不会释放并且其他线程可能被阻止。
这些情况可能导致意外行为，因此最好避免调用阻止函数
漏洞代码示例
1  #include <pthread.h>
2
3  void foo(pthread_mutex_t *mutex) {
4    pthread_mutex_lock(mutex);
5    sleep(30000);
6    pthread_mutex_unlock(mutex);
7  }
Klocwork 标记了第 5 行，指出当互斥在第 4 行被阻止时，
对阻止函数的调用进入了睡眠状态。
